{
  "stats": {
    "suites": 5,
    "tests": 37,
    "passes": 37,
    "pending": 0,
    "failures": 0,
    "start": "2025-10-03T02:24:55.305Z",
    "end": "2025-10-03T02:24:56.385Z",
    "duration": 1080,
    "testsRegistered": 37,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "28245781-7e53-4f9d-bce8-7d04fd6ad573",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [
        {
          "title": "\"before all\" hook: beforeAll in \"{root}\"",
          "fullTitle": "\"before all\" hook: beforeAll in \"{root}\"",
          "timedOut": false,
          "duration": 790,
          "state": null,
          "speed": null,
          "pass": false,
          "fail": false,
          "pending": false,
          "context": null,
          "code": "// allow first-time binary download\nif (typeof this.timeout === \"function\") this.timeout(30000);\nprocess.env.NODE_ENV = \"test\";\nprocess.env.JWT_SECRET = process.env.JWT_SECRET || \"test-secret\";\n// Start in-memory Mongo only if you actually need it.\n// (If you’re stubbing all DB calls, this still works—just a small overhead.)\nmongo = await MongoMemoryServer.create();\nconst uri = mongo.getUri();\n// Set BOTH env var names to avoid drift in app code\nprocess.env.MONGODB_URI = process.env.MONGODB_URI || uri;\nprocess.env.MONGO_URI   = process.env.MONGO_URI   || uri;",
          "err": {},
          "uuid": "8a022b38-4060-48a3-99d3-184ec3c61166",
          "parentUUID": "28245781-7e53-4f9d-bce8-7d04fd6ad573",
          "isHook": true,
          "skipped": false
        }
      ],
      "afterHooks": [
        {
          "title": "\"after all\" hook: afterAll in \"{root}\"",
          "fullTitle": "\"after all\" hook: afterAll in \"{root}\"",
          "timedOut": false,
          "duration": 89,
          "state": null,
          "speed": null,
          "pass": false,
          "fail": false,
          "pending": false,
          "context": null,
          "code": "if (mongo) {\n  await mongo.stop();\n}",
          "err": {},
          "uuid": "2db78780-5071-4c47-aa9a-92edc65a6f66",
          "parentUUID": "28245781-7e53-4f9d-bce8-7d04fd6ad573",
          "isHook": true,
          "skipped": false
        },
        {
          "title": "\"after each\" hook: afterEach in \"{root}\"",
          "fullTitle": "\"after each\" hook: afterEach in \"{root}\"",
          "timedOut": false,
          "duration": 0,
          "state": null,
          "speed": null,
          "pass": false,
          "fail": false,
          "pending": false,
          "context": null,
          "code": "sinon.restore();",
          "err": {},
          "uuid": "03ddcd3e-efc7-4459-9bf6-eb53b7f219c2",
          "parentUUID": "28245781-7e53-4f9d-bce8-7d04fd6ad573",
          "isHook": true,
          "skipped": false
        }
      ],
      "tests": [],
      "suites": [
        {
          "uuid": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
          "title": "auth.middleware",
          "fullFile": "E:\\Semester 2\\Assignment2\\medifinder\\backend\\test\\auth.middleware.test.js",
          "file": "\\test\\auth.middleware.test.js",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"auth.middleware\"",
              "fullTitle": "auth.middleware \"before each\" hook in \"auth.middleware\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sandbox = sinon.createSandbox();\nprocess.env.JWT_SECRET = \"unit-secret\";",
              "err": {},
              "uuid": "3d762114-bee7-45ea-9d7d-281db74694e0",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [
            {
              "title": "\"after each\" hook in \"auth.middleware\"",
              "fullTitle": "auth.middleware \"after each\" hook in \"auth.middleware\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sandbox.restore()",
              "err": {},
              "uuid": "20bad079-c526-483e-84d9-183579b51d67",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": true,
              "skipped": false
            }
          ],
          "tests": [
            {
              "title": "authenticate - 401 when no token",
              "fullTitle": "auth.middleware authenticate - 401 when no token",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { headers: {} };\nconst res = mkRes();\nconst next = sinon.spy();\nauthenticate(req, res, next);\nsinon.assert.calledWithExactly(res.status, 401);\nsinon.assert.calledWith(res.json, { error: \"Unauthorized\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "63708fbe-2aba-466a-bb8a-1c6229b35608",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "authenticate - 401 with invalid token",
              "fullTitle": "auth.middleware authenticate - 401 with invalid token",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { headers: { authorization: \"Bearer bad\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nsandbox.stub(jwt, \"verify\").throws(new Error(\"bad token\"));\nauthenticate(req, res, next);\nsinon.assert.calledWithExactly(res.status, 401);\nsinon.assert.calledWith(res.json, { error: \"Invalid token\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "cf521b94-5661-40db-849b-7a14b57dac31",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "authenticate - attaches payload & calls next on valid",
              "fullTitle": "auth.middleware authenticate - attaches payload & calls next on valid",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { headers: { authorization: \"Bearer good\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nconst payload = { sub: \"u1\", role: \"doctor\" };\nsandbox.stub(jwt, \"verify\").returns(payload);\nauthenticate(req, res, next);\nexpect(req.user).to.eql(payload);\nsinon.assert.calledOnce(next);",
              "err": {},
              "uuid": "1a6e19d8-6ed3-4164-8cb6-ff19ae593204",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "authenticate - passes token and env secret to jwt.verify",
              "fullTitle": "auth.middleware authenticate - passes token and env secret to jwt.verify",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { headers: { authorization: \"Bearer abc123\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nconst verify = sandbox.stub(jwt, \"verify\").returns({ sub: \"u1\" });\nauthenticate(req, res, next);\nsinon.assert.calledWithExactly(verify, \"abc123\", \"unit-secret\");\nsinon.assert.calledOnce(next);",
              "err": {},
              "uuid": "ead40a68-abda-4698-9e97-920407351197",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "authenticate - 401 when Authorization uses non-Bearer scheme",
              "fullTitle": "auth.middleware authenticate - 401 when Authorization uses non-Bearer scheme",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { headers: { authorization: \"Token abc123\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nauthenticate(req, res, next);\nsinon.assert.calledWithExactly(res.status, 401);\nsinon.assert.calledWith(res.json, { error: \"Unauthorized\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "114e2835-e971-479b-bdc3-8aae6af7c0c5",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "authenticate - 401 when 'Bearer' has no token",
              "fullTitle": "auth.middleware authenticate - 401 when 'Bearer' has no token",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { headers: { authorization: \"Bearer \" } }; \nconst res = mkRes();\nconst next = sinon.spy();\nauthenticate(req, res, next);\nsinon.assert.calledWithExactly(res.status, 401);\nsinon.assert.calledWith(res.json, { error: \"Unauthorized\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "90e6b86e-2564-4c52-a4ae-d62397ddbf53",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "authenticate - case-sensitive scheme: 'bearer' is rejected",
              "fullTitle": "auth.middleware authenticate - case-sensitive scheme: 'bearer' is rejected",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { headers: { authorization: \"bearer abc\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nauthenticate(req, res, next);\nsinon.assert.calledWithExactly(res.status, 401);\nsinon.assert.calledWith(res.json, { error: \"Unauthorized\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "da2182ff-958a-49a5-9755-c6854e0d51b9",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "requireRole - 401 if not authenticated",
              "fullTitle": "auth.middleware requireRole - 401 if not authenticated",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = {};\nconst res = mkRes();\nconst next = sinon.spy();\nrequireRole(\"doctor\")(req, res, next);\nsinon.assert.calledWithExactly(res.status, 401);\nsinon.assert.calledWith(res.json, { error: \"Unauthorized\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "6411cac7-2f9d-4304-a551-ff78385fa6aa",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "requireRole - 403 if wrong role",
              "fullTitle": "auth.middleware requireRole - 403 if wrong role",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { user: { role: \"patient\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nrequireRole(\"doctor\")(req, res, next);\nsinon.assert.calledWithExactly(res.status, 403);\nsinon.assert.calledWith(res.json, { error: \"Forbidden\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "9859f25f-8708-4834-b4a4-2e6dd4ce9a54",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "requireRole - role matching calls next",
              "fullTitle": "auth.middleware requireRole - role matching calls next",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { user: { role: \"doctor\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nrequireRole(\"doctor\")(req, res, next);\nsinon.assert.calledOnce(next);",
              "err": {},
              "uuid": "dad7315c-d96c-443f-bf82-3ed21adf489f",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "requireRole - case-sensitive comparison ('Doctor' ≠ 'doctor')",
              "fullTitle": "auth.middleware requireRole - case-sensitive comparison ('Doctor' ≠ 'doctor')",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { user: { role: \"Doctor\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nrequireRole(\"doctor\")(req, res, next);\nsinon.assert.calledWithExactly(res.status, 403);\nsinon.assert.calledWith(res.json, { error: \"Forbidden\" });\nsinon.assert.notCalled(next);",
              "err": {},
              "uuid": "4c840c8c-b659-471c-ae28-ee7b19c6fc22",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "requireRole - supports other roles (patient)",
              "fullTitle": "auth.middleware requireRole - supports other roles (patient)",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const req = { user: { role: \"patient\" } };\nconst res = mkRes();\nconst next = sinon.spy();\nrequireRole(\"patient\")(req, res, next);\nsinon.assert.calledOnce(next);",
              "err": {},
              "uuid": "93968e15-b27d-490a-993e-1e8cc5d75821",
              "parentUUID": "07a5faaa-0c6f-41b0-a64e-35d2969c9b67",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "63708fbe-2aba-466a-bb8a-1c6229b35608",
            "cf521b94-5661-40db-849b-7a14b57dac31",
            "1a6e19d8-6ed3-4164-8cb6-ff19ae593204",
            "ead40a68-abda-4698-9e97-920407351197",
            "114e2835-e971-479b-bdc3-8aae6af7c0c5",
            "90e6b86e-2564-4c52-a4ae-d62397ddbf53",
            "da2182ff-958a-49a5-9755-c6854e0d51b9",
            "6411cac7-2f9d-4304-a551-ff78385fa6aa",
            "9859f25f-8708-4834-b4a4-2e6dd4ce9a54",
            "dad7315c-d96c-443f-bf82-3ed21adf489f",
            "4c840c8c-b659-471c-ae28-ee7b19c6fc22",
            "93968e15-b27d-490a-993e-1e8cc5d75821"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16,
          "root": false,
          "rootEmpty": false,
          "_timeout": 20000
        },
        {
          "uuid": "73114720-e36d-4841-8b10-87f5b9d92643",
          "title": "Auth service",
          "fullFile": "E:\\Semester 2\\Assignment2\\medifinder\\backend\\test\\auth.service.test.js",
          "file": "\\test\\auth.service.test.js",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Auth service\"",
              "fullTitle": "Auth service \"before each\" hook in \"Auth service\"",
              "timedOut": false,
              "duration": 7,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "process.env.JWT_SECRET = \"unit-secret\";\nstubs = {\n  bcrypt: { genSalt: sinon.stub(), hash: sinon.stub(), compare: sinon.stub() },\n  jwt: { sign: sinon.stub() },\n  userModel: {\n    UserModel: {\n      findOne: sinon.stub(),\n      create: sinon.stub(),\n    },\n  },\n  userFactory: { createUser: sinon.stub() },\n};\nauth = proxyquire(\"../services/auth.service\", {\n  bcrypt: stubs.bcrypt,\n  jsonwebtoken: stubs.jwt,\n  \"../models/user.model\": stubs.userModel,\n  \"../shared/factories/user.factory\": stubs.userFactory,\n});",
              "err": {},
              "uuid": "a9c282d1-98a3-47d3-abce-be06f7e9efa1",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [
            {
              "title": "\"after each\" hook in \"Auth service\"",
              "fullTitle": "Auth service \"after each\" hook in \"Auth service\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sinon.restore()",
              "err": {},
              "uuid": "d90f5f3a-5b01-4890-a562-af7e19004a49",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": true,
              "skipped": false
            }
          ],
          "tests": [
            {
              "title": "signup() - creates a new user and returns JWT",
              "fullTitle": "Auth service signup() - creates a new user and returns JWT",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const payload = { name: \"  Pat  \", email: \"Pat@Example.com\", role: \"patient\", password: \"secret12\" };\nstubs.userModel.UserModel.findOne.returns({ lean: () => Promise.resolve(null) });\nstubs.userFactory.createUser.returns({\n  name: \"Pat\",\n  email: \"pat@example.com\",\n  role: \"patient\",\n});\nstubs.bcrypt.genSalt.resolves(\"salt\");\nstubs.bcrypt.hash.resolves(\"hashed-pw\");\nstubs.userModel.UserModel.create.resolves({\n  _id: { toString: () => \"user123\" },\n  name: \"Pat\",\n  email: \"pat@example.com\",\n  role: \"patient\",\n});\nstubs.jwt.sign.returns(\"jwt.token\");\nconst res = await auth.signup(payload);\nsinon.assert.calledWithMatch(stubs.userModel.UserModel.findOne, { email: \"pat@example.com\" });\nsinon.assert.calledWithMatch(stubs.userFactory.createUser, {\n  name: \"Pat\",\n  email: \"pat@example.com\",\n  role: \"patient\",\n});\nsinon.assert.calledWithExactly(stubs.bcrypt.genSalt, 10);\nsinon.assert.calledWithExactly(stubs.bcrypt.hash, \"secret12\", \"salt\");\nsinon.assert.calledWithMatch(stubs.userModel.UserModel.create, {\n  name: \"Pat\",\n  email: \"pat@example.com\",\n  role: \"patient\",\n  passwordHash: \"hashed-pw\",\n});\nsinon.assert.calledWithExactly(\n  stubs.jwt.sign,\n  { sub: \"user123\", role: \"patient\" },\n  \"unit-secret\",\n  { expiresIn: \"7d\" }\n);\nexpect(res).to.deep.equal({\n  user: { id: \"user123\", name: \"Pat\", email: \"pat@example.com\", role: \"patient\" },\n  token: \"jwt.token\",\n});",
              "err": {},
              "uuid": "a831fb68-48b2-425b-ae2a-92ef1531e839",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "signup() - rejects duplicate email",
              "fullTitle": "Auth service signup() - rejects duplicate email",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const payload = { name: \"Pat\", email: \"pat@example.com\", role: \"patient\", password: \"secret12\" };\nstubs.userModel.UserModel.findOne.returns({ lean: () => Promise.resolve({ _id: \"exists\" }) });\nawait expectReject(auth.signup(payload), /already registered|exist/i);\nsinon.assert.notCalled(stubs.userModel.UserModel.create);",
              "err": {},
              "uuid": "ee86c4a3-be78-498d-ae71-7ece86e73977",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "signup() - validates input and throws for bad email",
              "fullTitle": "Auth service signup() - validates input and throws for bad email",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await expectReject(\n  auth.signup({ name: \"Pat\", email: \"bad\", role: \"patient\", password: \"secret12\" }),\n  /invalid email/i\n);\nsinon.assert.notCalled(stubs.userModel.UserModel.findOne);",
              "err": {},
              "uuid": "64dad9e3-b492-47cc-b821-3a607745acb9",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "signup() - throws on invalid role",
              "fullTitle": "Auth service signup() - throws on invalid role",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await expectReject(\n  auth.signup({ name: \"Pat\", email: \"pat@example.com\", role: \"admin\", password: \"secret12\" }),\n  /invalid role/i\n);",
              "err": {},
              "uuid": "024ca361-c745-4fa7-97da-ea4b7408f93e",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "signup() - throws on short password",
              "fullTitle": "Auth service signup() - throws on short password",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await expectReject(\n  auth.signup({ name: \"Pat\", email: \"pat@example.com\", role: \"patient\", password: \"123\" }),\n  /password must be/i\n);",
              "err": {},
              "uuid": "0324c474-c480-46a6-bc75-f1a1cfc239a6",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "signup() - throws on short name",
              "fullTitle": "Auth service signup() - throws on short name",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await expectReject(\n  auth.signup({ name: \"A\", email: \"pat@example.com\", role: \"patient\", password: \"secret12\" }),\n  /at least 2/i\n);",
              "err": {},
              "uuid": "072c5020-6784-4e2c-86c1-124ffde7b9b7",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "login() - returns JWT on valid credentials",
              "fullTitle": "Auth service login() - returns JWT on valid credentials",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const emailInput = \"Pat@Example.com\"; // should be lowercased for query\nconst doc = {\n  _id: { toString: () => \"user123\" },\n  name: \"Pat\",\n  email: \"pat@example.com\",\n  role: \"patient\",\n  passwordHash: \"hashed-pw\",\n  locked: false,\n};\nconst select = sinon.stub().callsFake((s) => {\n  expect(s).to.equal(\"+passwordHash +locked\");\n  return { lean: () => Promise.resolve(doc) };\n});\nstubs.userModel.UserModel.findOne.callsFake((q) => {\n  expect(q).to.deep.equal({ email: \"pat@example.com\" });\n  return { select };\n});\nstubs.bcrypt.compare.resolves(true);\nstubs.jwt.sign.returns(\"jwt.token\");\nconst res = await auth.login({ email: emailInput, password: \"secret12\" });\nsinon.assert.calledOnce(stubs.userModel.UserModel.findOne);\nsinon.assert.calledOnce(stubs.bcrypt.compare);\nsinon.assert.calledWithExactly(\n  stubs.jwt.sign,\n  { sub: \"user123\", role: \"patient\" },\n  \"unit-secret\",\n  { expiresIn: \"7d\" }\n);\nexpect(res).to.deep.equal({\n  user: { id: \"user123\", name: \"Pat\", email: \"pat@example.com\", role: \"patient\" },\n  token: \"jwt.token\",\n});",
              "err": {},
              "uuid": "5c4c47a2-44cb-4bf3-b7de-3974acd40c92",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "login() - fails on wrong password",
              "fullTitle": "Auth service login() - fails on wrong password",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const doc = {\n  _id: { toString: () => \"user123\" },\n  name: \"Pat\",\n  email: \"pat@example.com\",\n  role: \"patient\",\n  passwordHash: \"hashed-pw\",\n  locked: false,\n};\nstubs.userModel.UserModel.findOne.returns({\n  select: () => ({ lean: () => Promise.resolve(doc) }),\n});\nstubs.bcrypt.compare.resolves(false);\nawait expectReject(\n  auth.login({ email: \"pat@example.com\", password: \"wrong\" }),\n  /invalid credentials|password/i\n);",
              "err": {},
              "uuid": "5094d39d-091f-4107-8400-cfbe5d7cfeb6",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "login() - rejects locked accounts",
              "fullTitle": "Auth service login() - rejects locked accounts",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const lockedDoc = {\n  _id: { toString: () => \"user123\" },\n  name: \"Pat\",\n  email: \"pat@example.com\",\n  role: \"patient\",\n  passwordHash: \"hashed-pw\",\n  locked: true,\n};\nstubs.userModel.UserModel.findOne.returns({\n  select: () => ({ lean: () => Promise.resolve(lockedDoc) }),\n});\ntry {\n  await auth.login({ email: \"pat@example.com\", password: \"whatever\" });\n  throw new Error(\"should not reach\");\n} catch (err) {\n  expect(String(err.message)).to.match(/locked/i);\n  expect(err).to.have.property(\"code\", \"LOCKED\");\n}",
              "err": {},
              "uuid": "316f8ac9-86e1-4cc9-b5e5-898262a859d3",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "login() - invalid email format is rejected before DB",
              "fullTitle": "Auth service login() - invalid email format is rejected before DB",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await expectReject(auth.login({ email: \"bad@\", password: \"x\" }), /invalid email/i);\nsinon.assert.notCalled(stubs.userModel.UserModel.findOne);",
              "err": {},
              "uuid": "902edf3b-5f54-4860-ba7b-192fd59693ed",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "login() - missing password rejected",
              "fullTitle": "Auth service login() - missing password rejected",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "await expectReject(auth.login({ email: \"pat@example.com\" }), /password required/i);\nsinon.assert.notCalled(stubs.userModel.UserModel.findOne);",
              "err": {},
              "uuid": "89b30bf0-5633-40d9-8cf1-296cbe47d42c",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "login() - user not found",
              "fullTitle": "Auth service login() - user not found",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "stubs.userModel.UserModel.findOne.returns({\n  select: () => ({ lean: () => Promise.resolve(null) }),\n});\nawait expectReject(auth.login({ email: \"pat@example.com\", password: \"secret12\" }), /invalid credentials/i);\nsinon.assert.notCalled(stubs.bcrypt.compare);",
              "err": {},
              "uuid": "44fb93b8-603e-46f2-a16d-a4c816e97efa",
              "parentUUID": "73114720-e36d-4841-8b10-87f5b9d92643",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "a831fb68-48b2-425b-ae2a-92ef1531e839",
            "ee86c4a3-be78-498d-ae71-7ece86e73977",
            "64dad9e3-b492-47cc-b821-3a607745acb9",
            "024ca361-c745-4fa7-97da-ea4b7408f93e",
            "0324c474-c480-46a6-bc75-f1a1cfc239a6",
            "072c5020-6784-4e2c-86c1-124ffde7b9b7",
            "5c4c47a2-44cb-4bf3-b7de-3974acd40c92",
            "5094d39d-091f-4107-8400-cfbe5d7cfeb6",
            "316f8ac9-86e1-4cc9-b5e5-898262a859d3",
            "902edf3b-5f54-4860-ba7b-192fd59693ed",
            "89b30bf0-5633-40d9-8cf1-296cbe47d42c",
            "44fb93b8-603e-46f2-a16d-a4c816e97efa"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 13,
          "root": false,
          "rootEmpty": false,
          "_timeout": 20000
        },
        {
          "uuid": "da4f3923-ed83-408b-bf90-18984ccc561a",
          "title": "Doctor profile service",
          "fullFile": "E:\\Semester 2\\Assignment2\\medifinder\\backend\\test\\doctor.service.test.js",
          "file": "\\test\\doctor.service.test.js",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Doctor profile service\"",
              "fullTitle": "Doctor profile service \"before each\" hook in \"Doctor profile service\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sandbox = sinon.createSandbox();",
              "err": {},
              "uuid": "a082503a-5d3f-440d-b7e1-48fed8ae0f4f",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [
            {
              "title": "\"after each\" hook in \"Doctor profile service\"",
              "fullTitle": "Doctor profile service \"after each\" hook in \"Doctor profile service\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sandbox.restore();",
              "err": {},
              "uuid": "90a6dc8a-5a19-4985-b44a-559c81d388b4",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": true,
              "skipped": false
            }
          ],
          "tests": [
            {
              "title": "getByUserId() - returns existing doc without creating",
              "fullTitle": "Doctor profile service getByUserId() - returns existing doc without creating",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst existing = { _id: new mongoose.Types.ObjectId(), userId };\nconst findOne = sandbox.stub(DoctorProfile, \"findOne\").resolves(existing);\nconst create = sandbox.stub(DoctorProfile, \"create\").resolves();\nconst result = await doctorService.getByUserId(userId);\nexpect(result).to.equal(existing);\nsinon.assert.calledOnce(findOne);\nsinon.assert.notCalled(create);",
              "err": {},
              "uuid": "92acf016-d509-4dd6-a632-3b414ac0cea5",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "getByUserId() - creates a profile if none exists",
              "fullTitle": "Doctor profile service getByUserId() - creates a profile if none exists",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst created = { _id: new mongoose.Types.ObjectId(), userId };\nsandbox.stub(DoctorProfile, \"findOne\").resolves(null);\nconst create = sandbox.stub(DoctorProfile, \"create\").resolves(created);\nconst result = await doctorService.getByUserId(userId);\nexpect(result).to.equal(created);\nsinon.assert.calledOnceWithExactly(create, { userId });",
              "err": {},
              "uuid": "494b321b-5507-4003-974a-cc76e2af5f16",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - updates allowed fields, trims strings, emits event + audit",
              "fullTitle": "Doctor profile service update() - updates allowed fields, trims strings, emits event + audit",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst before = {\n  userId: userId.toString(),\n  specialization: \"  old spec  \",\n  contact: \" 0000000000 \",\n};\nconst updated = {\n  _id: new mongoose.Types.ObjectId(),\n  userId,\n  specialization: \"Cardiology\",\n  contact: \"0123456789\",\n};\nconst patch = {\n  specialization: \"  Cardiology \",\n  contact: \" 0123456789 \",\n  hacker: \"ignore-me\",\n  userId: new mongoose.Types.ObjectId(),\n};\nconst findOne = sandbox.stub(DoctorProfile, \"findOne\").resolves({ toObject: () => before });\nconst findOneAndUpdate = sandbox.stub(DoctorProfile, \"findOneAndUpdate\").resolves(updated);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves(); \nconst res = await doctorService.update(userId, patch);\nexpect(res).to.equal(updated);\nsinon.assert.calledWithMatch(\n  findOneAndUpdate,\n  { userId },\n  { $set: { specialization: \"Cardiology\", contact: \"0123456789\" } },\n  { new: true, upsert: true }\n);\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", {\n  userId,\n  role: \"doctor\",\n  changes: [\"specialization\", \"contact\"],\n});\nsinon.assert.calledOnce(auditStub);\nsinon.assert.calledOnce(findOne);",
              "err": {},
              "uuid": "5d3e061a-74d3-4e5a-95a2-86c77d11baa2",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - empty/unknown patch → $set:{} ; emits [] changes ; audits",
              "fullTitle": "Doctor profile service update() - empty/unknown patch → $set:{} ; emits [] changes ; audits",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst existing = { _id: new mongoose.Types.ObjectId(), userId, specialization: \"Derm\", contact: \"111\" };\nsandbox.stub(DoctorProfile, \"findOne\").resolves({ toObject: () => existing });\nconst findOneAndUpdate = sandbox.stub(DoctorProfile, \"findOneAndUpdate\").resolves(existing);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves();\nconst res = await doctorService.update(userId, { foo: \"bar\", baz: true });\nexpect(res).to.equal(existing);\nsinon.assert.calledWithMatch(findOneAndUpdate, { userId }, { $set: {} }, { new: true, upsert: true });\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", { userId, role: \"doctor\", changes: [] });\nsinon.assert.calledOnce(auditStub);",
              "err": {},
              "uuid": "3e6b5f0f-003e-42f1-b7ba-380111df7cbe",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - partial: only specialization is updated & trimmed",
              "fullTitle": "Doctor profile service update() - partial: only specialization is updated & trimmed",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst before = { userId: userId.toString(), specialization: \"Derm\", contact: \"999\" };\nconst updated = { _id: new mongoose.Types.ObjectId(), userId, specialization: \"Neurology\", contact: \"999\" };\nsandbox.stub(DoctorProfile, \"findOne\").resolves({ toObject: () => before });\nconst findOneAndUpdate = sandbox.stub(DoctorProfile, \"findOneAndUpdate\").resolves(updated);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves();\nconst res = await doctorService.update(userId, { specialization: \"  Neurology \" });\nexpect(res).to.equal(updated);\nsinon.assert.calledWithMatch(\n  findOneAndUpdate,\n  { userId },\n  { $set: { specialization: \"Neurology\" } },\n  { new: true, upsert: true }\n);\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", { userId, role: \"doctor\", changes: [\"specialization\"] });\nsinon.assert.calledOnce(auditStub);",
              "err": {},
              "uuid": "9b944991-16fd-4c52-ab0e-7e51af19321b",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - blank contact kept as empty string after trim (and only that field changes)",
              "fullTitle": "Doctor profile service update() - blank contact kept as empty string after trim (and only that field changes)",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst before = { userId: userId.toString(), specialization: \"Derm\", contact: \"999\" };\nconst updated = { _id: new mongoose.Types.ObjectId(), userId, specialization: \"Derm\", contact: \"\" };\nsandbox.stub(DoctorProfile, \"findOne\").resolves({ toObject: () => before });\nconst findOneAndUpdate = sandbox.stub(DoctorProfile, \"findOneAndUpdate\").resolves(updated);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves();\nconst res = await doctorService.update(userId, { contact: \"   \" });\nexpect(res).to.equal(updated);\nsinon.assert.calledWithMatch(\n  findOneAndUpdate,\n  { userId },\n  { $set: { contact: \"\" } },\n  { new: true, upsert: true }\n);\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", { userId, role: \"doctor\", changes: [\"contact\"] });\nsinon.assert.calledOnce(auditStub);",
              "err": {},
              "uuid": "64f522b7-1c0f-4135-bfcf-417583ff23ec",
              "parentUUID": "da4f3923-ed83-408b-bf90-18984ccc561a",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "92acf016-d509-4dd6-a632-3b414ac0cea5",
            "494b321b-5507-4003-974a-cc76e2af5f16",
            "5d3e061a-74d3-4e5a-95a2-86c77d11baa2",
            "3e6b5f0f-003e-42f1-b7ba-380111df7cbe",
            "9b944991-16fd-4c52-ab0e-7e51af19321b",
            "64f522b7-1c0f-4135-bfcf-417583ff23ec"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 10,
          "root": false,
          "rootEmpty": false,
          "_timeout": 20000
        },
        {
          "uuid": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
          "title": "Patient profile service",
          "fullFile": "E:\\Semester 2\\Assignment2\\medifinder\\backend\\test\\patient.service.test.js",
          "file": "\\test\\patient.service.test.js",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"Patient profile service\"",
              "fullTitle": "Patient profile service \"before each\" hook in \"Patient profile service\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sandbox = sinon.createSandbox();",
              "err": {},
              "uuid": "ced39a33-9a8c-4d81-88a0-530f7f6694cf",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [
            {
              "title": "\"after each\" hook in \"Patient profile service\"",
              "fullTitle": "Patient profile service \"after each\" hook in \"Patient profile service\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sandbox.restore();",
              "err": {},
              "uuid": "968e3ce7-e378-4226-8778-d51853c2284b",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": true,
              "skipped": false
            }
          ],
          "tests": [
            {
              "title": "getByUserId() - returns existing doc without creating",
              "fullTitle": "Patient profile service getByUserId() - returns existing doc without creating",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst existing = { _id: new mongoose.Types.ObjectId(), userId };\nconst findOne = sandbox.stub(PatientProfile, \"findOne\").resolves(existing);\nconst create = sandbox.stub(PatientProfile, \"create\").resolves();\nconst result = await patientService.getByUserId(userId);\nexpect(result).to.equal(existing);\nsinon.assert.calledOnce(findOne);\nsinon.assert.notCalled(create);",
              "err": {},
              "uuid": "7cdbda82-c130-4fc5-83a2-63424f558bc9",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "getByUserId() - creates a profile if none exists",
              "fullTitle": "Patient profile service getByUserId() - creates a profile if none exists",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst created = { _id: new mongoose.Types.ObjectId(), userId };\nsandbox.stub(PatientProfile, \"findOne\").resolves(null);\nconst create = sandbox.stub(PatientProfile, \"create\").resolves(created);\nconst result = await patientService.getByUserId(userId);\nexpect(result).to.equal(created);\nsinon.assert.calledOnceWithExactly(create, { userId });",
              "err": {},
              "uuid": "2de56c27-e3b2-4afd-8cce-efbf58d95272",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - updates allowed fields, trims strings, emits event",
              "fullTitle": "Patient profile service update() - updates allowed fields, trims strings, emits event",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst before = { userId: userId.toString(), contact: \"  old  \", address: \"Old\", dateOfBirth: null };\nconst updated = {\n  _id: new mongoose.Types.ObjectId(),\n  userId,\n  contact: \"0123456789\",\n  address: \"New Address\",\n  dateOfBirth: new Date(\"1999-01-01\"),\n};\nconst patch = {\n  contact: \" 0123456789 \",\n  address: \" New Address \",\n  dateOfBirth: new Date(\"1999-01-01\"),\n  hacker: \"should be ignored\",\n  userId: new mongoose.Types.ObjectId(), // should be ignored\n};\nconst findOne = sandbox.stub(PatientProfile, \"findOne\").resolves({ toObject: () => before });\nconst findOneAndUpdate = sandbox.stub(PatientProfile, \"findOneAndUpdate\").resolves(updated);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves();\nconst res = await patientService.update(userId, patch);\nexpect(res).to.equal(updated);\nsinon.assert.calledWithMatch(\n  findOneAndUpdate,\n  { userId },\n  { $set: { dateOfBirth: patch.dateOfBirth, contact: \"0123456789\", address: \"New Address\" } },\n  { new: true, upsert: true }\n);\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", {\n  userId,\n  role: \"patient\",\n  changes: [\"dateOfBirth\", \"contact\", \"address\"],\n});\nsinon.assert.calledOnce(auditStub);\nsinon.assert.calledOnce(findOne);",
              "err": {},
              "uuid": "9b3fa50f-b32e-4bf7-a340-cc443113403f",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - empty/unknown patch results in $set:{} and emits [] changes, audits once",
              "fullTitle": "Patient profile service update() - empty/unknown patch results in $set:{} and emits [] changes, audits once",
              "timedOut": false,
              "duration": 3,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst existing = { _id: new mongoose.Types.ObjectId(), userId, contact: \"c\", address: \"a\" };\nsandbox.stub(PatientProfile, \"findOne\").resolves({ toObject: () => existing });\nconst findOneAndUpdate = sandbox.stub(PatientProfile, \"findOneAndUpdate\").resolves(existing);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves();\nconst res = await patientService.update(userId, { ignored: true, alsoIgnored: 1 });\nexpect(res).to.equal(existing);\nsinon.assert.calledWithMatch(findOneAndUpdate, { userId }, { $set: {} }, { new: true, upsert: true });\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", { userId, role: \"patient\", changes: [] });\nsinon.assert.calledOnce(auditStub);",
              "err": {},
              "uuid": "9a8015f9-e8ab-498a-b4b7-827d4448bb3d",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - partial: updates only contact and trims",
              "fullTitle": "Patient profile service update() - partial: updates only contact and trims",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst before = { userId: userId.toString(), contact: \"old\", address: \"keep\" };\nconst updated = { _id: new mongoose.Types.ObjectId(), userId, contact: \"0001112222\", address: \"keep\" };\nsandbox.stub(PatientProfile, \"findOne\").resolves({ toObject: () => before });\nconst findOneAndUpdate = sandbox.stub(PatientProfile, \"findOneAndUpdate\").resolves(updated);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves();\nconst res = await patientService.update(userId, { contact: \" 0001112222 \" });\nexpect(res).to.equal(updated);\nsinon.assert.calledWithMatch(\n  findOneAndUpdate,\n  { userId },\n  { $set: { contact: \"0001112222\" } },\n  { new: true, upsert: true }\n);\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", {\n  userId,\n  role: \"patient\",\n  changes: [\"contact\"],\n});\nsinon.assert.calledOnce(auditStub);",
              "err": {},
              "uuid": "4f8db8c5-c7f8-404b-a71f-4fb4867e0c67",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "update() - ignores falsy dateOfBirth but keeps trimmed empty address",
              "fullTitle": "Patient profile service update() - ignores falsy dateOfBirth but keeps trimmed empty address",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const userId = new mongoose.Types.ObjectId();\nconst before = { userId: userId.toString(), contact: \"c\", address: \"a\" };\nconst updated = { _id: new mongoose.Types.ObjectId(), userId, contact: \"c\", address: \"\" };\nsandbox.stub(PatientProfile, \"findOne\").resolves({ toObject: () => before });\nconst findOneAndUpdate = sandbox.stub(PatientProfile, \"findOneAndUpdate\").resolves(updated);\nconst emit = sandbox.stub(eventBus, \"emit\");\nconst auditStub = sandbox.stub(AuditLog, \"create\").resolves();\nconst res = await patientService.update(userId, { dateOfBirth: null, address: \"   \" });\nexpect(res).to.equal(updated);\nsinon.assert.calledWithMatch(\n  findOneAndUpdate,\n  { userId },\n  { $set: { address: \"\" } },\n  { new: true, upsert: true }\n);\nsinon.assert.calledOnceWithExactly(emit, \"profile.updated\", {\n  userId,\n  role: \"patient\",\n  changes: [\"address\"],\n});\nsinon.assert.calledOnce(auditStub);",
              "err": {},
              "uuid": "7d425835-645c-45ed-bb83-460d06c68828",
              "parentUUID": "6bfa0b57-79a0-408e-ac34-970c4990fc2e",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "7cdbda82-c130-4fc5-83a2-63424f558bc9",
            "2de56c27-e3b2-4afd-8cce-efbf58d95272",
            "9b3fa50f-b32e-4bf7-a340-cc443113403f",
            "9a8015f9-e8ab-498a-b4b7-827d4448bb3d",
            "4f8db8c5-c7f8-404b-a71f-4fb4867e0c67",
            "7d425835-645c-45ed-bb83-460d06c68828"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 11,
          "root": false,
          "rootEmpty": false,
          "_timeout": 20000
        },
        {
          "uuid": "49312d90-d603-47e0-9a83-bb5b1d43924e",
          "title": "Smoke test",
          "fullFile": "E:\\Semester 2\\Assignment2\\medifinder\\backend\\test\\smoke.test.js",
          "file": "\\test\\smoke.test.js",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "runs the test suite",
              "fullTitle": "Smoke test runs the test suite",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "expect(true).to.be.true;",
              "err": {},
              "uuid": "48571052-f1a8-484d-a80a-55088de46a64",
              "parentUUID": "49312d90-d603-47e0-9a83-bb5b1d43924e",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "48571052-f1a8-484d-a80a-55088de46a64"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 20000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 20000
    }
  ],
  "meta": {
    "mocha": {
      "version": "11.7.4"
    },
    "mochawesome": {
      "options": {
        "quiet": true,
        "reportFilename": "mochawesome",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.4"
    },
    "marge": {
      "options": {
        "reportDir": "mochawesome-report",
        "reportFilename": "mochawesome",
        "inlineAssets": "true",
        "quiet": "true"
      },
      "version": "6.3.0"
    }
  }
}